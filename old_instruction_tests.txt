   /* // LD TEST
    cout << "CYCLES: " << global_mem.get_cycles() << endl;
    global_mem.write("00000000", "01110001111000001000000000000000"); //write 2nd arg to addr in 1st arg. rn address is 00001000 (addr of value we want loaded into register)
    global_mem.write("00001000", "11111111111111111000111111111111"); // write value we want loaded (2nd arg) to mem addr = rn
    fetch(global_pc, global_mem, reg);
    cout << "FINISHED LD EXECUTION. PRINTING RESULTS..." << endl;
    cout << "reg 0: " << reg[0] << endl;
    cout << "cache address 00000000: \n" << global_mem.view("00000000", "1") << endl;
    cout << "NEW PC: " << global_pc << endl;
    cout << "CYCLES: " << global_mem.get_cycles() << endl;
    cout << "finish\n\n\n\n" << endl;

    // STR TEST
    cout << "CYCLES: " << global_mem.get_cycles() << endl;
    global_mem.write("00000001", "00000010001000000100000100000000"); //write 2nd arg to addr in 1st arg. rn address is 00000100 (addr of memory we want register value in)
    reg[1] = "11111111111111111111111111111111"; // value we're going to put into the memory address above (00000001)
    fetch(global_pc, global_mem, reg);
    cout << "FINISHED STR EXECUTION. PRINTING RESULTS..." << endl;
    cout << "reg 1, should be all 1's (doesn't change): " << reg[1] << endl;
    cout << "cache address 00000100, should be all 1's (we stored reg 0's value here): \n" << global_mem.view("00000100", "1") << endl;
    cout << "NEW PC: " << global_pc << endl;
    cout << "CYCLES: " << global_mem.get_cycles() << endl;
    cout << "finish\n\n\n\n" << endl;

    // ADD TEST
    reg[2] = "00000000000000000000000000000001"; // 1st operand
    reg[3] = "00000000000000000000000000000001"; // 2nd operand
    string cond = "0000";
    string is_branch = "0";
    string i_bit = "0";
    string opcode = "00000";
    string s_bit = "0";
    string rn = "0010"; // first operand for add, reg[2] above
    string rd = "0100"; // dest register for add, we want reg[4]
    string shifter_operand = "001100000000"; // second operand register (reg[3]) + options for shift and constants
    global_mem.write("00000010", cond + is_branch + i_bit + opcode + s_bit + rn + rd + shifter_operand); // write command to memory
    fetch(global_pc, global_mem, reg);
    cout << "FINISHED ADD EXECUTION. PRINTING RESULTS..." << endl;
    cout << "REG[4], SHOULD BE 00000000000000000000000000000010: \n" + reg[4] << endl;
    cout << "NEW PC: " << global_pc << endl;
    cout << "CYCLES: " << global_mem.get_cycles() << endl;
    cout << "finish\n\n\n\n" << endl;


    // CMP AND LOOP JOINT TEST
    reg[2] = "00000000000000000000000000000001"; // 1st operand, 1
    reg[3] = "00000000000000000000000000000001"; // 2nd operand, 1
    cond = "0111"; // should save loop addr
    is_branch = "0";
    i_bit = "0";
    opcode = "01010";
    s_bit = "0";
    rn = "0010"; // first operand, reg[2] above
    rd = "0000"; // dest register, it'll ALWAYS BE GLOBAL_CMP and is set within decode(), so THIS DOESN'T MATTER
    shifter_operand = "001100000000"; // second operand register (reg[3]) + options for shift and constants
    global_mem.write("00000011", cond + is_branch + i_bit + opcode + s_bit + rn + rd + shifter_operand); // write command to memory
    fetch(global_pc, global_mem, reg);
    cout << "FINISHED CMP EXECUTION. PRINTING RESULTS..." << endl;
    cout << "RESULT (global_cmp), SHOULD BE 01: " + global_cmp << endl;
    cout << "GLOBAL LOOP, SHOULD BE BINARY VERSION OF THIS INSTRUCTION'S PC (3): " << global_loop << endl;
    cout << "NEW PC: " << global_pc << endl;
    cout << "CYCLES: " << global_mem.get_cycles() << endl;
    cout << "finish\n\n\n\n" << endl;

*/
    //BRANCH TEST -> THIS IS THE COUNTING LOOP

    CODE FORMAT
    /*string cond = "0011"; // less than cond code
    string is_branch = "0";
    string i_bit = "0";
    string opcode = "11000";
    string s_bit = "0";
    string target_address = "00000000000000000000"; // always will be global_loop where we look for this, DOESN'T MATTER
    global_mem.write("00000000", "0000 0 0 01111 0 00000111 0000 00000000"); // write first LD instruction to mem[0] (LD mem[7] to reg[0])
    global_mem.write("00000001", "0000 0 0 01111 0 00001000 0001 00000000"); // write second LD instruction to mem[1] (LD mem[8] to reg[1])
    global_mem.write("00000010", "0000 0 0 01111 0 00001001 0010 00000000");// write third LD instruction to mem[2] (LD mem[9] to reg[2])
    global_mem.write("00000011", "0000 0 0 00000 0 0000 0000 000100000000"); // write ADD command to mem[3] (ADD reg[0], reg[0], reg[1]).
    global_mem.write("00000100", "0000 0 0 01010 0 0000 0000 001000000000");// write CMP command to mem[4]. Compare reg[0] to reg[2], which holds 5 in binary. (CMP reg[0], reg[2], store result in global_cmp)
    global_mem.write("00000101", "0011 0 0 11000 0 00000000000000000011"); // write B to mem[5] (BLT target_address). The target addr is the first ins of loop. set less than cond code. target_addr is always global_loop
    global_mem.write("00000110", "0000 0 0 10001 0 00001010 0000 00000000") // write STR command to mem[6]. STR reg[0] into mem[10] at the end of the counting loop
    global_mem.write("00000111", "00000000000000000000000000000000"); // write 0 to mem[7]. we're adding 1 to this value in a loop
    global_mem.write("00001000", "00000000000000000000000000000001"); // write 1 to mem[8]. This is the "1" we're adding to em[6] every loop
    global_mem.write("00001001", "00000000000000000000000000000101"); // write 5 to mem[9]. We're CMPing this and mem[7] (reg[0]) to see if reg[0] is less than this*/

    FROM FILE FORMAT
    w 00000000 00000001111000000111000000000000 p
    w 00000001 00000001111000001000000100000000 p
    w 00000010 00000001111000001001001000000000 p
    w 00000011 00000000000000000000000100000000 p
    w 00000100 00000001010000000000001000000000 p
    w 00000101 00110011000000000000000000000011 p
    w 00000110 00000010001000001010000000000000 p
    w 00000111 00000000000000000000000000000000 n
    w 00001000 00000000000000000000000000000001 n
    w 00001001 00000000000000000000000000000101 n


    // SUB TEST - END RESULT SHOULD BE 00000000000000000000000000000001 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00001 0 0000 0010 000100000000 p // SUB reg[0] - reg[1] and store it in reg[2]
    w 00000011 00000000000000000000000000000101 n // write 5 to mem[3]
    w 00000100 00000000000000000000000000000100 n // write 4 to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000001000000010000100000000 p
    w 00000011 00000000000000000000000000000101 n
    w 00000100 00000000000000000000000000000100 n


    // MUL TEST - END RESULT SHOULD BE 00000000000000000000000000010100 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00010 0 0000 0010 000100000000 p // MUL reg[0] * reg[1] and store it in reg[2]
    w 00000011 00000000000000000000000000000101 n // write 5 to mem[3]
    w 00000100 00000000000000000000000000000100 n // write 4 to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000010000000010000100000000 p
    w 00000011 00000000000000000000000000000101 n
    w 00000100 00000000000000000000000000000100 n


    // DIV TEST - END RESULT SHOULD BE 00000000000000000000000000000010 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00011 0 0000 0010 000100000000 p // DIV reg[0] / reg[1] and store it in reg[2]
    w 00000011 00000000000000000000000000000110 n // write 6 to mem[3]
    w 00000100 00000000000000000000000000000011 n // write 3 to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000011000000010000100000000 p
    w 00000011 00000000000000000000000000000110 n
    w 00000100 00000000000000000000000000000011 n

    DIVIDE BY 0 TEST
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000011000000010000100000000 p
    w 00000011 00000000000000000000000000000110 n
    w 00000100 00000000000000000000000000000000 n


    // MOD TEST - END RESULT SHOULD BE 00000000000000000000000000000001 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00100 0 0000 0010 000100000000 p // MOD reg[0] % reg[1] and store it in reg[2]
    w 00000011 00000000000000000000000000000101 n // write 5 to mem[3]
    w 00000100 00000000000000000000000000000100 n // write 4 to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000100000000010000100000000 p
    w 00000011 00000000000000000000000000000101 n
    w 00000100 00000000000000000000000000000100 n


    MOD BY 0 TEST
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000100000000010000100000000 p
    w 00000011 00000000000000000000000000000101 n
    w 00000100 00000000000000000000000000000000 n


    // AND TEST - END RESULT SHOULD BE 00000000000000000000010100000100 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00101 0 0000 0010 000100000000 p // AND reg[0] && reg[1] and store it in reg[2]
    w 00000011 00000000000000000000010100000101 n // write to mem[3]
    w 00000100 00000000000000000000111100000100 n // write to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000101000000010000100000000 p
    w 00000011 00000000000000000000010100000101 n
    w 00000100 00000000000000000000111100000100 n


    // OR TEST - END RESULT SHOULD BE 00000000000000000000111100000101 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00111 0 0000 0010 000100000000 p // OR reg[0] || reg[1] and store it in reg[2]
    w 00000011 00000000000000000000010100000101 n // write to mem[3]
    w 00000100 00000000000000000000111100000100 n // write to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000111000000010000100000000 p
    w 00000011 00000000000000000000010100000101 n
    w 00000100 00000000000000000000111100000100 n


    // NOT TEST - END RESULT SHOULD BE 11111111000010111111101011111010 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand, NOT USED)
    w 00000010 0000 0 0 01000 0 0000 0010 000000000000 p // NOT reg[0] and store it in reg[2]
    w 00000011 00000000111101000000010100000101 n // write to mem[3]
    w 00000100 00000000000000000000111100000100 n // write to mem[4], NOT USED

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000001000000000010000000000000 p
    w 00000011 00000000111101000000010100000101 n
    w 00000100 00000000000000000000111100000100 n


    // XOR TEST - END RESULT SHOULD BE 00000000000000000000101000000001 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 01001 0 0000 0010 000100000000 p // XOR reg[0] x|| reg[1] and store it in reg[2]
    w 00000011 00000000000000000000010100000101 n // write to mem[3]
    w 00000100 00000000000000000000111100000100 n // write to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000001001000000010000100000000 p
    w 00000011 00000000000000000000010100000101 n
    w 00000100 00000000000000000000111100000100 n


    // MOV TEST - END RESULT SHOULD BE 00000000000000000000010100000101 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (NOT USED)
    w 00000010 0000 0 0 01011 0 0000 0010 000000000000 p // MOV reg[0] into reg[2]
    w 00000011 00000000000000000000010100000101 n // write to mem[3]
    w 00000100 00000000000000000000111100000100 n // write to mem[4], NOT USED

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000001011000000010000000000000 p
    w 00000011 00000000000000000000010100000101 n
    w 00000100 00000000000000000000111100000100 n  


    // LS TEST - END RESULT SHOULD BE 00000000000000000000000000110000 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand, UNUSED)
    w 00000010 0000 0 0 10111 0 0000 0010 000110000000 p // LS reg[0] 3 spaces and store it in reg[2]
    w 00000011 11100000000000000000000000000110 n // write to mem[3]
    w 00000100 00000000000000000000000000000011 n // write to mem[4], UNUSED

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000010111000000010000110000000 p
    w 00000011 11100000000000000000000000000110 n
    w 00000100 00000000000000000000000000000011 n

    // RS TEST - END RESULT SHOULD BE 00011100000000000000000000011000 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand, UNUSED)
    w 00000010 0000 0 0 10000 0 0000 0010 000110000000 p // RS reg[0] 3 spaces and store it in reg[2]
    w 00000011 11100000000000000000000011000110 n // write to mem[3]
    w 00000100 00000000000000000000000000000011 n // write to mem[4], UNUSED

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000010000000000010000110000000 p
    w 00000011 11100000000000000000000011000110 n
    w 00000100 00000000000000000000000000000011 n


    // BASIC COUNTING LOOP ASSEMBLY THAT WORKS:
    LD r0, m7
    LD r1, m8
    LD r2, m9
    ADD r0, r0, r1
    CMP r0, r0, r2
    BLT m3
    STR r0, m6
    
    
    // 4/12 DEMO PROGRAM
    SUBTRACTION TO 0 LOOP, ADD 4 TO IT, MULTIPLY BY 4, DIVIDE BY 2, MOD 2, AND IT WITH ONE REG, OR IT WITH ANOTHER, NOT, XOR WITH AND REG, MOV TO ANOTHER REG, LS BY 2, RS BY 4
    reg[0] = 5, reg[1] = 1, reg[2] = 0, reg[3] = 4
    
    THEORETICAL CODE FORMAT
    global_mem.write("00000000", "0000 0 0 01111 0 00010101 0000 00000000"); // write first LD instruction to mem[0] (LD mem[21] to reg[0])
    global_mem.write("00000001", "0000 0 0 01111 0 00010110 0001 00000000"); // write second LD instruction to mem[1] (LD mem[22] to reg[1])
    global_mem.write("00000010", "0000 0 0 01111 0 00010111 0010 00000000");// write third LD instruction to mem[2] (LD mem[23] to reg[2])
    global_mem.write("00000011", "0000 0 0 00001 0 0000 0000 000100000000"); // write SUB command to mem[3] (SUB reg[0], reg[0], reg[1])
    global_mem.write("00000100", "0000 0 0 01010 0 0000 0000 001000000000");// write CMP command to mem[4]. Compare reg[0] to reg[2], which holds 0 in binary. (CMP reg[0], reg[2], store result in global_cmp)
    global_mem.write("00000101", "0101 0 0 11000 0 00000000000000000011"); // write B to mem[5] (BGT target_address). The target addr is the first ins of loop. set greater than cond code
    global_mem.write("00000110", "0000 0 0 10001 0 00011001 0000 00000000"); // write STR command to mem[6]. STR reg[0] into mem[25] at the end of the counting loop
    RESULT SHOULD BE 0 in reg[0], 1 in reg[1], 0 in reg[2]
    global_mem.write("00000111", "0000 0 0 01111 0 00011000 0011 00000000"); // write LD ins to mem[7] (LD mem[24] into reg[3])
    global_mem.write("00001000", "0000 0 0 00000 0 0000 0000 001100000000"); // write ADD ins to mem[8] (ADD reg[3] to reg[0])
    RESULT SHOULD BE 4 IN REG[0]
    global_mem.write("00001001", "0000 0 0 00010 0 0000 0000 000000000000"); // write MUL ins to mem[9] (MUL reg[0] by reg[0])
    RESULT SHOULD BE 16 IN REG[0]
    global_mem.write("00001010", "0000 0 0 00000 0 0001 0001 000100000000"); // write ADD ins to mem[10] (ADD reg[1] TO reg[1])
    RESULT SHOULD BE 2 IN REG[1]
    global_mem.write("00001011", "0000 0 0 00011 0 0000 0000 000100000000"); // write DIV ins to mem[11] (DIV reg[0] by reg[1])
    RESULT SHOULD BE 8 IN REG[0]
    global_mem.write("00001100", "0000 0 0 00100 0 0000 0000 000100000000"); // write MOD ins to mem[12] (MOD reg[0] by reg[1])
    RESULT SHOULD BE 0 IN REG[0]
    global_mem.write("00001101", "0000 0 0 00101 0 0000 0000 000100000000"); // write AND ins to mem[13] (AND reg[0] w/ reg[1])
    RESULT SHOULD STILL BE 0 IN REG[0]
    global_mem.write("00001110", "0000 0 0 00111 0 0000 0000 001100000000"); // write OR ins to mem[14] (OR reg[0] w/ reg[3])
    RESULT SHOULD BE 4 IN REG[0]
    global_mem.write("00001111", "0000 0 0 01000 0 0000 0000 000000000000"); // write NOT ins to mem[15] (NOT reg[0])
    RESULT SHOULD BE 11111111111111111111111111111011 IN REG[0]
    global_mem.write("00010000", "0000 0 0 01001 0 0000 0000 000100000000"); // write XOR ins to mem[16] (XOR reg[0] w/ reg[1])
    RESULT SHOULD BE 11111111111111111111111111111001 IN REG[0]
    global_mem.write("00010001", "0000 0 0 01011 0 0000 0010 000000000000"); // write MOV ins to mem[17] (MOV reg[0] to reg[2])
    RESULT SHOULD BE 11111111111111111111111111111001 IN REG[0] AND REG[2]
    global_mem.write("00010010", "0000 0 0 10111 0 0010 0010 000100000000"); // write LS ins to mem[18] (LS reg[2] by 2)
    RESULT SHOULD BE 11111111111111111111111111100100 IN REG[2]
    global_mem.write("00010011", "0000 0 0 10000 0 0010 0010 001000000000"); // write RS ins to mem[19] (RS reg[2] by 4)
    RESULT SHOULD BE 00001111111111111111111111111110 IN REG[2]
    global_mem.write("00010100", "0000 0 0 10001 0 00011010 0010 00000000"); // write STR ins to mem[20] (STR reg[2] in mem[26])
    global_mem.write("00010101", "00000000000000000000000000000101"); // write 5 to mem[21]. we're subtracting 1 to this value in a loop
    global_mem.write("00010110", "00000000000000000000000000000001"); // write 1 to mem[22]. This is the "1" we're adding to em[6] every loop
    global_mem.write("00010111", "00000000000000000000000000000000"); // write 0 to mem[23]. We're CMPing this and mem[7] (reg[0]) to see if reg[0] is less than this*/
    global_mem.write("00011000", "00000000000000000000000000000100"); // write 4 to mem[24]. 

    FINAL RESULT SHOULD BE:
    reg[0] = 11111111111111111111111111111001
    reg[1] = 00000000000000000000000000000010
    reg[2] = 00001111111111111111111111111110
    reg[3] = 00000000000000000000000000000100
    mem[25] = 00000000000000000000000000000000
    mem[26] = 00001111111111111111111111111110

    FORMAT FOR FILE
    w 00000000 00000001111000010101000000000000 p
    w 00000001 00000001111000010110000100000000 p
    w 00000010 00000001111000010111001000000000 p
    w 00000011 00000000001000000000000100000000 p
    w 00000100 00000001010000000000001000000000 p
    w 00000101 01010011000000000000000000000011 p
    w 00000110 00000010001000011001000000000000 p
    w 00000111 00000001111000011000001100000000 p
    w 00001000 00000000000000000000001100000000 p
    w 00001001 00000000010000000000000000000000 p
    w 00001010 00000000000000010001000100000000 p
    w 00001011 00000000011000000000000100000000 p
    w 00001100 00000000100000000000000100000000 p
    w 00001101 00000000101000000000000100000000 p
    w 00001110 00000000111000000000001100000000 p
    w 00001111 00000001000000000000000000000000 p
    w 00010000 00000001001000000000000100000000 p
    w 00010001 00000001011000000010000000000000 p
    w 00010010 00000010111000100010000100000000 p
    w 00010011 00000010000000100010001000000000 p
    w 00010100 00000010001000011010001000000000 p
    w 00010101 00000000000000000000000000000101 n
    w 00010110 00000000000000000000000000000001 n
    w 00010111 00000000000000000000000000000000 n
    w 00011000 00000000000000000000000000000100 n

    ASSEMBLER FORMAT (OLD SLOW WAY USING ALL REGISTERS, STILL WORKS OFC):
    LD r0, m21
    LD r1, m22
    LD r2, m23
    SUB r0, r0, r1
    CMP r0, r2
    BGT m3
    STR r0, m25
    LD r3, m24
    ADD r0, r0, r3
    MUL r0, r0, r0
    ADD r1, r1, r1
    DIV r0, r0, r1
    MOD r0, r0, r1
    AND r0, r0, r1
    OR r0, r0, r3
    NOT r0, r0
    XOR r0, r0, r1
    MOV r2, r0
    LS r2, r2, #2
    RS r2, r2, #4
    STR r2, m26
    
    ASSEMBLER FORMAT (NEW WAY USING #'s):
    LD r0, m21
    SUB r0, r0, #1
    CMP r0, #0
    BGT m1
    STR r0, m25
    ADD r0, r0, #4
    MUL r0, r0, #4
    DIV r0, r0, #2
    MOD r0, r0, #2
    AND r0, r0, #2
    OR r0, r0, #4
    NOT r0, r0
    XOR r0, r0, #2
    MOV r1, r0
    LS r1, r1, #2
    RS r1, r1, #4
    STR r1, m26