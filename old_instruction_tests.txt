   /* // LD TEST
    cout << "CYCLES: " << global_mem.get_cycles() << endl;
    global_mem.write("00000000", "01110001111000001000000000000000"); //write 2nd arg to addr in 1st arg. rn address is 00001000 (addr of value we want loaded into register)
    global_mem.write("00001000", "11111111111111111000111111111111"); // write value we want loaded (2nd arg) to mem addr = rn
    fetch(global_pc, global_mem, reg);
    cout << "FINISHED LD EXECUTION. PRINTING RESULTS..." << endl;
    cout << "reg 0: " << reg[0] << endl;
    cout << "cache address 00000000: \n" << global_mem.view("00000000", "1") << endl;
    cout << "NEW PC: " << global_pc << endl;
    cout << "CYCLES: " << global_mem.get_cycles() << endl;
    cout << "finish\n\n\n\n" << endl;

    // STR TEST
    LD r0, m3
    ADD r1, #2, #2
    STR r0, r1
    w 00000011 11111111111111111000111111111111

    // ADD TEST
    reg[2] = "00000000000000000000000000000001"; // 1st operand
    reg[3] = "00000000000000000000000000000001"; // 2nd operand
    string cond = "0000";
    string is_branch = "0";
    string i_bit = "0";
    string opcode = "00000";
    string s_bit = "0";
    string rn = "0010"; // first operand for add, reg[2] above
    string rd = "0100"; // dest register for add, we want reg[4]
    string shifter_operand = "001100000000"; // second operand register (reg[3]) + options for shift and constants
    global_mem.write("00000010", cond + is_branch + i_bit + opcode + s_bit + rn + rd + shifter_operand); // write command to memory
    fetch(global_pc, global_mem, reg);
    cout << "FINISHED ADD EXECUTION. PRINTING RESULTS..." << endl;
    cout << "REG[4], SHOULD BE 00000000000000000000000000000010: \n" + reg[4] << endl;
    cout << "NEW PC: " << global_pc << endl;
    cout << "CYCLES: " << global_mem.get_cycles() << endl;
    cout << "finish\n\n\n\n" << endl;


    // CMP AND LOOP JOINT TEST
    reg[2] = "00000000000000000000000000000001"; // 1st operand, 1
    reg[3] = "00000000000000000000000000000001"; // 2nd operand, 1
    cond = "0111"; // should save loop addr
    is_branch = "0";
    i_bit = "0";
    opcode = "01010";
    s_bit = "0";
    rn = "0010"; // first operand, reg[2] above
    rd = "0000"; // dest register, it'll ALWAYS BE GLOBAL_CMP and is set within decode(), so THIS DOESN'T MATTER
    shifter_operand = "001100000000"; // second operand register (reg[3]) + options for shift and constants
    global_mem.write("00000011", cond + is_branch + i_bit + opcode + s_bit + rn + rd + shifter_operand); // write command to memory
    fetch(global_pc, global_mem, reg);
    cout << "FINISHED CMP EXECUTION. PRINTING RESULTS..." << endl;
    cout << "RESULT (global_cmp), SHOULD BE 01: " + global_cmp << endl;
    cout << "GLOBAL LOOP, SHOULD BE BINARY VERSION OF THIS INSTRUCTION'S PC (3): " << global_loop << endl;
    cout << "NEW PC: " << global_pc << endl;
    cout << "CYCLES: " << global_mem.get_cycles() << endl;
    cout << "finish\n\n\n\n" << endl;

*/
    //BRANCH TEST -> THIS IS THE COUNTING LOOP

    CODE FORMAT
    /*string cond = "0011"; // less than cond code
    string is_branch = "0";
    string i_bit = "0";
    string opcode = "11000";
    string s_bit = "0";
    string target_address = "00000000000000000000"; // always will be global_loop where we look for this, DOESN'T MATTER
    global_mem.write("00000000", "0000 0 0 01111 0 00000111 0000 00000000"); // write first LD instruction to mem[0] (LD mem[7] to reg[0])
    global_mem.write("00000001", "0000 0 0 01111 0 00001000 0001 00000000"); // write second LD instruction to mem[1] (LD mem[8] to reg[1])
    global_mem.write("00000010", "0000 0 0 01111 0 00001001 0010 00000000");// write third LD instruction to mem[2] (LD mem[9] to reg[2])
    global_mem.write("00000011", "0000 0 0 00000 0 0000 0000 000100000000"); // write ADD command to mem[3] (ADD reg[0], reg[0], reg[1]).
    global_mem.write("00000100", "0000 0 0 01010 0 0000 0000 001000000000");// write CMP command to mem[4]. Compare reg[0] to reg[2], which holds 5 in binary. (CMP reg[0], reg[2], store result in global_cmp)
    global_mem.write("00000101", "0011 0 0 11000 0 00000000000000000011"); // write B to mem[5] (BLT target_address). The target addr is the first ins of loop. set less than cond code. target_addr is always global_loop
    global_mem.write("00000110", "0000 0 0 10001 0 00001010 0000 00000000") // write STR command to mem[6]. STR reg[0] into mem[10] at the end of the counting loop
    global_mem.write("00000111", "00000000000000000000000000000000"); // write 0 to mem[7]. we're adding 1 to this value in a loop
    global_mem.write("00001000", "00000000000000000000000000000001"); // write 1 to mem[8]. This is the "1" we're adding to em[6] every loop
    global_mem.write("00001001", "00000000000000000000000000000101"); // write 5 to mem[9]. We're CMPing this and mem[7] (reg[0]) to see if reg[0] is less than this*/

    FROM FILE FORMAT
    w 00000000 00000001111000000111000000000000 p
    w 00000001 00000001111000001000000100000000 p
    w 00000010 00000001111000001001001000000000 p
    w 00000011 00000000000000000000000100000000 p
    w 00000100 00000001010000000000001000000000 p
    w 00000101 00110011000000000000000000000011 p
    w 00000110 00000010001000001010000000000000 p
    w 00000111 00000000000000000000000000000000 n
    w 00001000 00000000000000000000000000000001 n
    w 00001001 00000000000000000000000000000101 n


    // SUB TEST - END RESULT SHOULD BE 00000000000000000000000000000001 IN REG[2]
    LD r0, m3 // LD mem[3] to reg[0] (first operand)
    LD r1, m4 // LD mem[4] to reg[1] (second operand)
    SUB r2, r0, r1 // SUB reg[0] - reg[1] and store it in reg[2]
    w 00000011 00000000000000000000000000000101 // write 5 to mem[3]
    w 00000100 00000000000000000000000000000100 // write 4 to mem[4]

    GOOD FORMAT FOR FILE
    LD r0, m3
    LD r1, m4
    SUB r2, r0, r1
    
    PROGRAM SETUP
    w 00000011 00000000000000000000000000000101
    w 00000100 00000000000000000000000000000100


    // MUL TEST - END RESULT SHOULD BE 00000000000000000000000000010100 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00010 0 0000 0010 000100000000 p // MUL reg[0] * reg[1] and store it in reg[2]
    w 00000011 00000000000000000000000000000101 n // write 5 to mem[3]
    w 00000100 00000000000000000000000000000100 n // write 4 to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000010000000010000100000000 p
    w 00000011 00000000000000000000000000000101 n
    w 00000100 00000000000000000000000000000100 n


    // DIV TEST - END RESULT SHOULD BE 00000000000000000000000000000010 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00011 0 0000 0010 000100000000 p // DIV reg[0] / reg[1] and store it in reg[2]
    w 00000011 00000000000000000000000000000110 n // write 6 to mem[3]
    w 00000100 00000000000000000000000000000011 n // write 3 to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000011000000010000100000000 p
    w 00000011 00000000000000000000000000000110 n
    w 00000100 00000000000000000000000000000011 n

    DIVIDE BY 0 TEST
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000011000000010000100000000 p
    w 00000011 00000000000000000000000000000110 n
    w 00000100 00000000000000000000000000000000 n


    // MOD TEST - END RESULT SHOULD BE 00000000000000000000000000000001 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00100 0 0000 0010 000100000000 p // MOD reg[0] % reg[1] and store it in reg[2]
    w 00000011 00000000000000000000000000000101 n // write 5 to mem[3]
    w 00000100 00000000000000000000000000000100 n // write 4 to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000100000000010000100000000 p
    w 00000011 00000000000000000000000000000101 n
    w 00000100 00000000000000000000000000000100 n


    MOD BY 0 TEST
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000100000000010000100000000 p
    w 00000011 00000000000000000000000000000101 n
    w 00000100 00000000000000000000000000000000 n


    // AND TEST - END RESULT SHOULD BE 00000000000000000000010100000100 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00101 0 0000 0010 000100000000 p // AND reg[0] && reg[1] and store it in reg[2]
    w 00000011 00000000000000000000010100000101 n // write to mem[3]
    w 00000100 00000000000000000000111100000100 n // write to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000101000000010000100000000 p
    w 00000011 00000000000000000000010100000101 n
    w 00000100 00000000000000000000111100000100 n


    // OR TEST - END RESULT SHOULD BE 00000000000000000000111100000101 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00111 0 0000 0010 000100000000 p // OR reg[0] || reg[1] and store it in reg[2]
    w 00000011 00000000000000000000010100000101 n // write to mem[3]
    w 00000100 00000000000000000000111100000100 n // write to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000111000000010000100000000 p
    w 00000011 00000000000000000000010100000101 n
    w 00000100 00000000000000000000111100000100 n


    // NOT TEST - END RESULT SHOULD BE 11111111000010111111101011111010 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand, NOT USED)
    w 00000010 0000 0 0 01000 0 0000 0010 000000000000 p // NOT reg[0] and store it in reg[2]
    w 00000011 00000000111101000000010100000101 n // write to mem[3]
    w 00000100 00000000000000000000111100000100 n // write to mem[4], NOT USED

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000001000000000010000000000000 p
    w 00000011 00000000111101000000010100000101 n
    w 00000100 00000000000000000000111100000100 n


    // XOR TEST - END RESULT SHOULD BE 00000000000000000000101000000001 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 01001 0 0000 0010 000100000000 p // XOR reg[0] x|| reg[1] and store it in reg[2]
    w 00000011 00000000000000000000010100000101 n // write to mem[3]
    w 00000100 00000000000000000000111100000100 n // write to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000001001000000010000100000000 p
    w 00000011 00000000000000000000010100000101 n
    w 00000100 00000000000000000000111100000100 n


    // MOV TEST - END RESULT SHOULD BE 00000000000000000000010100000101 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (NOT USED)
    w 00000010 0000 0 0 01011 0 0000 0010 000000000000 p // MOV reg[0] into reg[2]
    w 00000011 00000000000000000000010100000101 n // write to mem[3]
    w 00000100 00000000000000000000111100000100 n // write to mem[4], NOT USED

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000001011000000010000000000000 p
    w 00000011 00000000000000000000010100000101 n
    w 00000100 00000000000000000000111100000100 n  


    // LS TEST - END RESULT SHOULD BE 00000000000000000000000000110000 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand, UNUSED)
    w 00000010 0000 0 0 10111 0 0000 0010 000110000000 p // LS reg[0] 3 spaces and store it in reg[2]
    w 00000011 11100000000000000000000000000110 n // write to mem[3]
    w 00000100 00000000000000000000000000000011 n // write to mem[4], UNUSED

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000010111000000010000110000000 p
    w 00000011 11100000000000000000000000000110 n
    w 00000100 00000000000000000000000000000011 n

    // RS TEST - END RESULT SHOULD BE 00011100000000000000000000011000 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand, UNUSED)
    w 00000010 0000 0 0 10000 0 0000 0010 000110000000 p // RS reg[0] 3 spaces and store it in reg[2]
    w 00000011 11100000000000000000000011000110 n // write to mem[3]
    w 00000100 00000000000000000000000000000011 n // write to mem[4], UNUSED

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000010000000000010000110000000 p
    w 00000011 11100000000000000000000011000110 n
    w 00000100 00000000000000000000000000000011 n


    // BASIC COUNTING LOOP ASSEMBLY THAT WORKS:
    LD r0, m7
    LD r1, m8
    LD r2, m9
    ADD r0, r0, r1
    CMP r0, r0, r2
    BLT m3
    STR r0, m6
    
    
    // 4/12 DEMO PROGRAM
    SUBTRACTION TO 0 LOOP, ADD 4 TO IT, MULTIPLY BY 4, DIVIDE BY 2, MOD 2, AND IT WITH ONE REG, OR IT WITH ANOTHER, NOT, XOR WITH AND REG, MOV TO ANOTHER REG, LS BY 2, RS BY 4
    reg[0] = 5, reg[1] = 1, reg[2] = 0, reg[3] = 4
    
    THEORETICAL CODE FORMAT
    global_mem.write("00000000", "0000 0 0 01111 0 00010101 0000 00000000"); // write first LD instruction to mem[0] (LD mem[21] to reg[0])
    global_mem.write("00000001", "0000 0 0 01111 0 00010110 0001 00000000"); // write second LD instruction to mem[1] (LD mem[22] to reg[1])
    global_mem.write("00000010", "0000 0 0 01111 0 00010111 0010 00000000");// write third LD instruction to mem[2] (LD mem[23] to reg[2])
    global_mem.write("00000011", "0000 0 0 00001 0 0000 0000 000100000000"); // write SUB command to mem[3] (SUB reg[0], reg[0], reg[1])
    global_mem.write("00000100", "0000 0 0 01010 0 0000 0000 001000000000");// write CMP command to mem[4]. Compare reg[0] to reg[2], which holds 0 in binary. (CMP reg[0], reg[2], store result in global_cmp)
    global_mem.write("00000101", "0101 0 0 11000 0 00000000000000000011"); // write B to mem[5] (BGT target_address). The target addr is the first ins of loop. set greater than cond code
    global_mem.write("00000110", "0000 0 0 10001 0 00011001 0000 00000000"); // write STR command to mem[6]. STR reg[0] into mem[25] at the end of the counting loop
    RESULT SHOULD BE 0 in reg[0], 1 in reg[1], 0 in reg[2]
    global_mem.write("00000111", "0000 0 0 01111 0 00011000 0011 00000000"); // write LD ins to mem[7] (LD mem[24] into reg[3])
    global_mem.write("00001000", "0000 0 0 00000 0 0000 0000 001100000000"); // write ADD ins to mem[8] (ADD reg[3] to reg[0])
    RESULT SHOULD BE 4 IN REG[0]
    global_mem.write("00001001", "0000 0 0 00010 0 0000 0000 000000000000"); // write MUL ins to mem[9] (MUL reg[0] by reg[0])
    RESULT SHOULD BE 16 IN REG[0]
    global_mem.write("00001010", "0000 0 0 00000 0 0001 0001 000100000000"); // write ADD ins to mem[10] (ADD reg[1] TO reg[1])
    RESULT SHOULD BE 2 IN REG[1]
    global_mem.write("00001011", "0000 0 0 00011 0 0000 0000 000100000000"); // write DIV ins to mem[11] (DIV reg[0] by reg[1])
    RESULT SHOULD BE 8 IN REG[0]
    global_mem.write("00001100", "0000 0 0 00100 0 0000 0000 000100000000"); // write MOD ins to mem[12] (MOD reg[0] by reg[1])
    RESULT SHOULD BE 0 IN REG[0]
    global_mem.write("00001101", "0000 0 0 00101 0 0000 0000 000100000000"); // write AND ins to mem[13] (AND reg[0] w/ reg[1])
    RESULT SHOULD STILL BE 0 IN REG[0]
    global_mem.write("00001110", "0000 0 0 00111 0 0000 0000 001100000000"); // write OR ins to mem[14] (OR reg[0] w/ reg[3])
    RESULT SHOULD BE 4 IN REG[0]
    global_mem.write("00001111", "0000 0 0 01000 0 0000 0000 000000000000"); // write NOT ins to mem[15] (NOT reg[0])
    RESULT SHOULD BE 11111111111111111111111111111011 IN REG[0]
    global_mem.write("00010000", "0000 0 0 01001 0 0000 0000 000100000000"); // write XOR ins to mem[16] (XOR reg[0] w/ reg[1])
    RESULT SHOULD BE 11111111111111111111111111111001 IN REG[0]
    global_mem.write("00010001", "0000 0 0 01011 0 0000 0010 000000000000"); // write MOV ins to mem[17] (MOV reg[0] to reg[2])
    RESULT SHOULD BE 11111111111111111111111111111001 IN REG[0] AND REG[2]
    global_mem.write("00010010", "0000 0 0 10111 0 0010 0010 000100000000"); // write LS ins to mem[18] (LS reg[2] by 2)
    RESULT SHOULD BE 11111111111111111111111111100100 IN REG[2]
    global_mem.write("00010011", "0000 0 0 10000 0 0010 0010 001000000000"); // write RS ins to mem[19] (RS reg[2] by 4)
    RESULT SHOULD BE 00001111111111111111111111111110 IN REG[2]
    global_mem.write("00010100", "0000 0 0 10001 0 00011010 0010 00000000"); // write STR ins to mem[20] (STR reg[2] in mem[26])
    global_mem.write("00010101", "00000000000000000000000000000101"); // write 5 to mem[21]. we're subtracting 1 to this value in a loop
    global_mem.write("00010110", "00000000000000000000000000000001"); // write 1 to mem[22]. This is the "1" we're adding to em[6] every loop
    global_mem.write("00010111", "00000000000000000000000000000000"); // write 0 to mem[23]. We're CMPing this and mem[7] (reg[0]) to see if reg[0] is less than this*/
    global_mem.write("00011000", "00000000000000000000000000000100"); // write 4 to mem[24]. 

    FINAL RESULT SHOULD BE:
    reg[0] = 11111111111111111111111111111001
    reg[1] = 00000000000000000000000000000010
    reg[2] = 00001111111111111111111111111110
    reg[3] = 00000000000000000000000000000100
    mem[25] = 00000000000000000000000000000000
    mem[26] = 00001111111111111111111111111110

    FORMAT FOR FILE
    w 00000000 00000001111000010101000000000000 p
    w 00000001 00000001111000010110000100000000 p
    w 00000010 00000001111000010111001000000000 p
    w 00000011 00000000001000000000000100000000 p
    w 00000100 00000001010000000000001000000000 p
    w 00000101 01010011000000000000000000000011 p
    w 00000110 00000010001000011001000000000000 p
    w 00000111 00000001111000011000001100000000 p
    w 00001000 00000000000000000000001100000000 p
    w 00001001 00000000010000000000000000000000 p
    w 00001010 00000000000000010001000100000000 p
    w 00001011 00000000011000000000000100000000 p
    w 00001100 00000000100000000000000100000000 p
    w 00001101 00000000101000000000000100000000 p
    w 00001110 00000000111000000000001100000000 p
    w 00001111 00000001000000000000000000000000 p
    w 00010000 00000001001000000000000100000000 p
    w 00010001 00000001011000000010000000000000 p
    w 00010010 00000010111000100010000100000000 p
    w 00010011 00000010000000100010001000000000 p
    w 00010100 00000010001000011010001000000000 p
    w 00010101 00000000000000000000000000000101 n
    w 00010110 00000000000000000000000000000001 n
    w 00010111 00000000000000000000000000000000 n
    w 00011000 00000000000000000000000000000100 n

    ASSEMBLER FORMAT (OLD SLOW WAY USING ALL REGISTERS, STILL WORKS OFC):
    LD r0, m21
    LD r1, m22
    LD r2, m23
    SUB r0, r0, r1
    CMP r0, r2
    BGT m3
    STR r0, m25
    LD r3, m24
    ADD r0, r0, r3
    MUL r0, r0, r0
    ADD r1, r1, r1
    DIV r0, r0, r1
    MOD r0, r0, r1
    AND r0, r0, r1
    OR r0, r0, r3
    NOT r0, r0
    XOR r0, r0, r1
    MOV r2, r0
    LS r2, r2, #2
    RS r2, r2, #4
    STR r2, m26
    
    ASSEMBLER FORMAT (NEW WAY USING #'s):
    LD r0, m21
    SUB r0, r0, #1
    CMP r0, #0
    BGT m1
    STR r0, m25
    ADD r0, r0, #4
    MUL r0, r0, #4
    DIV r0, r0, #2
    MOD r0, r0, #2
    AND r0, r0, #2
    OR r0, r0, #4
    NOT r0, r0
    XOR r0, r0, #2
    MOV r1, r0
    LS r1, r1, #2
    RS r1, r1, #4
    STR r1, m26

    PROGRAM SETUP:
    w 00010101 00000000000000000000000000000101 n
    w 00010110 00000000000000000000000000000001 n
    w 00010111 00000000000000000000000000000000 n
    w 00011000 00000000000000000000000000000100 n



    *********BENCHMARKS**********

    **BENCHMARK 1: EXCHANGE SORT**
    memory will hold array of values
    r0 = 
    r1 = size of array we're sorting
    r2 = 1st operand to compare in inner loop sort
    r3 = 2nd operand to compare in inner loop sort
    r4 = counter for outer loop
    r5 = limit the outer loop can count up to
    r6 = counter for inner loop
    r7 = limit the inner loop can count up to
    r8 = offset marking the memory location of the first index of array to be sorted
    r9 = changes, has memory address of current index we want for inner loop
    
    EXCHANGE SORT ASSEMBLER FORMAT + PROGRAM SETUP (w/ explanation)
    LD r8, m57 // loads offset to beginning of array (24) for sort into r8: 0
    LD r1, m56 // loads size of array (30) into r1: 1

    ADD r4, r4, #0 // set outer counter to 0: 2
    SUB r5, r1, #2 // set outer loop limit to (size of array - 2): 3

    ADD r6, r6, #0 // set inner counter to 0, BRANCH TO HERE FOR TOP OF OUTER LOOP: 4
    SUB r7, r5, r4 // set inner loop limit to (size of array - 2 - outer counter): 5

    CMP r6, r7 // compare inner counter to inner loop limit, BRANCH TO HERE FOR TOP OF INNER LOOP: 6
    BGT m19 // branch to the end of the inner loop if greater than, we're done with this inner loop: 7
    ADD r9, r6, r8 // add inner counter and mem offset, r9 has int val of memory location with array value we need: 8
    LD r2, r9 // load the value at the memory location in r9 to r2, first operand: 9
    ADD r9, r9, #1 // add 1 to the memory location so we can get the adjacent value to compare: 10
    LD r3, r9 // load the value at the memory location in r9 to r2, second operand: 11
    CMP r2, r3 // compare the operands: 12
    ADD r6, r6, #1 // add 1 to inner count for an iteration in case we don't go down to reverse values and branch back up: 13
    BLTE m6 // if they're in the right order (r2 <= r3), just iterate again and don't update anything: 14
    STR r2, r9 // if r2 > r3, store r2 where r3 was in memory: 15
    SUB r9, r9, #1 // if r2 > r3, decrement r9 back to r2's original memory location: 16
    STR r3, r9 // if r2 > r3, store r3 where r2 was in memory. Now these 2 values are in the right order.: 17
    B m6 // repeat inner loop iteration for next two array values: 18

    ADD r4, r4, #1 // increment counter of outer loop. BRANCH HERE FOR THE END OF INNER LOOP, FIRST INS AFTER END: 19
    CMP r4, r5 // compare outer loop limit and counter: 20
    BLTE m4 // repeat if the counter is <= the limit: 21

    // write all 30 array values to memory locations 25 - 55
    w 00011001 00000000000000000000000000011011 // 25
    w 00011010 00000000000000000000000000011111 // 26
    w 00011011 00110000000000000000000000011000 // 27
    w 00011100 00000001100000000000000000000000 // 28
    w 00011101 10000000000000000000000000011000 // 29
    w 00011110 00100000000000000000000000011011 // 30
    w 00011111 00100000000000000000000000011000 // 31
    w 00100000 00100001111000000000000000011011 // 32
    w 00100001 00000001111000000000000000011011 // 33
    w 00100010 00100001111000000000000000000011 // 34
    w 00100011 00100001101000000000000000011011 // 35
    w 00100100 10100001111000000000000000011011 // 36
    w 00100101 00101101111000000000000000011011 // 37
    w 00100110 00100000000000001010000000011011 // 38
    w 00100111 00100000000001001010000000011011 // 39
    w 00101000 00100000000000001010000000011000 // 40
    w 00101001 00100100000000001010000000011011 // 41
    w 00101010 00101100000000001010000000011011 // 42
    w 00101011 00100000000000001010000000000011 // 43
    w 00101100 00100011110000001010000000011011 // 44
    w 00101101 00100000000000000000000000011011 // 45
    w 00101110 11100000000000001010000000011011 // 46
    w 00101111 00000000000000001010000000011011 // 47
    w 00110000 00100000000000001010000000000000 // 48
    w 00110001 11111000000000001010000000011011 // 49
    w 00110010 11111000000000001010000000011000 // 50
    w 00110011 00000000000000001010000000011000 // 51
    w 00110100 00000000000000001010000000000011 // 52
    w 00110101 01000000000000001010000000000000 // 53
    w 00110110 01100000000000001010000000000011 // 54

    w 00110111 00000000000110000000000000011000 // 55
    w 00111000 00000000000000000000000000011110 // WRITE 30 (size of array) TO memory: 56
    w 00111001 00000000000000000000000000011001 // WRITE 25 (# of instructions + # of writes for program setup) to memory: 57




    
    ASSEMBLER INSTRUCTIONS AND PROGRAM SETUP IN FILE FORMAT:
    LD r8, m57
    LD r1, m56
    ADD r4, #0, #0
    SUB r5, r1, #1
    ADD r6, #0, #0
    SUB r7, r5, r4
    CMP r6, r7
    BGT m19
    ADD r9, r6, r8
    LD r2, r9
    ADD r9, r9, #1
    LD r3, r9
    CMP r2, r3
    ADD r6, r6, #1
    BLTE m6
    STR r2, r9
    SUB r9, r9, #1
    STR r3, r9
    B m6
    ADD r4, r4, #1
    CMP r4, r5
    BLTE m4

    w 00011001 00000000000000000000000000011011
    w 00011010 00000000000000000000000000011111
    w 00011011 00000000000000000000000000011000
    w 00011100 00000000000000000000000000000001
    w 00011101 00000000000000000000000000011000
    w 00011110 00000000000000000000000000011011
    w 00011111 00000000000000000000000000011000
    w 00100000 00000000000000000000000000011011
    w 00100001 00000000000000000000000000011011
    w 00100010 00000000000000000000000000000011
    w 00100011 00000000000000000000000000011011
    w 00100100 00000000000000000000000000011011
    w 00100101 00000000000000000000000000011011
    w 00100110 00000000000000001010000000011011
    w 00100111 00000000000001001010000000011011
    w 00101000 00000000000000001010000000011000
    w 00101001 00000000000000001010000000011011
    w 00101010 00000000000000001010000000011011
    w 00101011 00000000000000001010000000000011
    w 00101100 00000000000000001010000000011011
    w 00101101 00000000000000000000000000011011
    w 00101110 00000000000000001010000000011011
    w 00101111 00000000000000001010000000011011
    w 00110000 00100000000000001010000000000000
    w 00110001 11111000000000001010000000011011
    w 00110010 11111000000000001010000000011000
    w 00110011 00000000000000001010000000011000
    w 00110100 00000000000000001010000000000011
    w 00110101 00000000000000001010000000000000
    w 00110110 00000000000000001010000000000011
    w 00110111 00000000000110000000000000011000
    w 00111000 00000000000000000000000000011110
    w 00111001 00000000000000000000000000011000

    
    
    **BENCHMARK 2: MATRIX MULTIPLY**
    r0 = size of matrix 1/outer count limit
    r1 = size of matrix 2/inner count limit
    r2 = outer count iterator starting at 0
    r3 = inner count iterator starting at 0
    r4 = holds result of current row * column number math
    r5 = holds current index of which member of row/column we're on to multiply
    r6 = temporarily holds result of multiply for two specific numbers. added to r4 later
    r7 = holds memory location of matrix 1 operand we're multiplying later holds actual value
    r8 = offset of instructions + program setup - points to first member of matrix 1
    r9 = holds total size of matrix 1 for matrix 2 offset (64)
    r10 = holds memory location of matrix 2 operand we multiply, later holds actual value
    r11 = used for calculating matrix 2 column member to multiply 
    r12 = starts with beginning of where we can store complete matrix, increments as we store results


    inner inner, inner and outer loop
        LD r0, m167 // load length of matrix 1 rows into r0. assumes is square matrix. acts as outer count limit (8), 0
        LD r1, m168 // load length of matrix 2 columns into r0. assumes is square matrix. acts as inner count limit (8), 1
        LD r8, m169 // load offset of instructions + program setup (points to first member of matrix 1), 2
        LD r9, m165 // load total size of matrix 1 for matrix 2 offset (64), 3
        LD r12, m166 // load start of where we can store new matrix, 4
        ADD r2, #0, #0 // initialize outer iteration counter to 0, 5
    outer is each row in matrix 1
        CMP r2, r0 // compare and see if we're at the end of matrix 1, end program if so. BRANCH HERE FOR START OF OUTER LOOP, 6
        BGT m33 // if r0 > 8, we're done with matrix 1 and therefore entire program, 7
        ADD r3, #0, #0 // initialize inner counter to 0, 8
    inner is each column in matrix 2
        CMP r3, r1 // compare inner counter to inner matrix column size. branch to outer loop if former is larger (done with matrix 1 row). BRANCH HERE FOR INNER LOOP, 9
        ADDGT r2, r2, #1 // increment r2 if it was larger, move to next row of matrix 1, 10
        BGT m6// branch to outer loop if we're done with this row of matrix 1, 11
    inner inner is for doing the math
        ADD r4, #0, #0 // initialize reg holding eventual final result of current inner inner math., 12
        ADD r5, #0, #0 // initialize index of row/column to 0, 13
        MUL r7, r0, r2 // gets memory location of start of matrix 1 row without offset. START OF INNER INNER LOOP, 14
        ADD r7, r7, r8 // adds offset of instructions/program setup to it. Holds memory loc of start of current row of matrix 1, 15
        ADD r7, r7, r5 // adds offset of current index to then get specific operand. This is the memory location of the operand for matrix 1 we're multiplying, 16

        ADD r10, #0, r3 // memory location of first member of current matrix 2 column without any offsets, 17
        ADD r10, r10, r8 // add instruction/program setup offset, 18
        ADD r10, r10, r9 // add offset of matrix 1 size, 19
        MUL r11, r0, r5 // multiply row length by the index of the column we want, 20
        ADD r10, r10, r11 // add the offset of the specific member of the column we want. This is the memory location of the operand for matrix 2 we're multiplying, 21

        LD r7, r7 // loads actual operand from the memory location into the register we had the memory location in for matrix 1, 22
        LD r10, r10 // loads actual operand from the memory location into the register we had the memory location in for matrix 2, 23
        MUL r6, r7, r10 // multiply element of mtrx1 and element of mtrx2., 24
        ADD r4, r4, r6 // add to r4 total result, 25
        ADD r5, r5, #1 // increment counter for index, 26
        CMP r5, r0 // if counter is larger than row/column length..., 27
        STRGT r4, r12 // ...store the result number, 28
        ADDGT r12, r12, #1 // increment addr available for storage of new matrix, 29
        ADDGT r3, r3, #1 // ...increment counter for inner -> move to next column of matrix 2, 30
        BGT m9 // ...branch back to inner loop, done, 31
        B m14 // else branch back to the start of inner inner loop, 32
    END OF PROGRAM
        ADDLTE r15, #0, #0 // dummy instruction for end of program, 33

    w 00100101 00000000000000000000000000001000 // matrix 1 index 0, 37
    w 00100110 00000000000000000000000000001010 // matrix 1 index 1, 38
    w 00100111 00000000000000000000000000001011 // matrix 1 index 2, 39
    w 00101000 00000000000000000000000000000100 // matrix 1 index 3, 40
    w 00101001 00000000000000000000000000000001 // matrix 1 index 4, 41
    w 00101010 00000000000000000000000000000100 // matrix 1 index 5, 42
    w 00101011 00000000000000000000000000000010 // matrix 1 index 6, 43
    w 00101100 00000000000000000000000000000011 // matrix 1 index 7, 44
    w 00101101 00000000000000000000000000000111 // matrix 1 index 8, 45
    w 00101110 00000000000000000000000000000110 // matrix 1 index 9, 46
    w 00101111 00000000000000000000000000010110 // matrix 1 index 10, 47
    w 00110000 00000000000000000000000000010111 // matrix 1 index 11, 48
    w 00110001 00000000000000000000000000000111 // matrix 1 index 12, 49
    w 00110010 00000000000000000000000000000110 // matrix 1 index 13, 50
    w 00110011 00000000000000000000000000000100 // matrix 1 index 14, 51
    w 00110100 00000000000000000000000000000101 // matrix 1 index 15, 52
    w 00110101 00000000000000000000000000000111 // matrix 1 index 16, 53
    w 00110110 00000000000000000000000000001111 // matrix 1 index 17, 54
    w 00110111 00000000000000000000000000001001 // matrix 1 index 18, 55
    w 00111000 00000000000000000000000000000001 // matrix 1 index 19, 56
    w 00111001 00000000000000000000000000000101 // matrix 1 index 20, 57
    w 00111010 00000000000000000000000000000100 // matrix 1 index 21, 58
    w 00111011 00000000000000000000000000010000 // matrix 1 index 22, 59
    w 00111100 00000000000000000000000000001000 // matrix 1 index 23, 60
    w 00111101 00000000000000000000000000000010 // matrix 1 index 24, 61
    w 00111110 00000000000000000000000000000011 // matrix 1 index 25, 62
    w 00111111 00000000000000000000000000000111 // matrix 1 index 26, 63
    w 01000000 00000000000000000000000000000110 // matrix 1 index 27, 64
    w 01000001 00000000000000000000000000000100 // matrix 1 index 28, 65
    w 01000010 00000000000000000000000000001100 // matrix 1 index 29, 66
    w 01000011 00000000000000000000000000001101 // matrix 1 index 30, 67
    w 01000100 00000000000000000000000000001111 // matrix 1 index 31, 68
    w 01000101 00000000000000000000000010000000 // matrix 1 index 32, 69
    w 01000110 00000000000000000000000010000001 // matrix 1 index 33, 70
    w 01000111 00000000000000000000000010000010 // matrix 1 index 34, 71
    w 01001000 00000000000000000000000010000011 // matrix 1 index 35, 72
    w 01001001 00000000000000000000000010000111 // matrix 1 index 36, 73
    w 01001010 00000000000000000000000010000101 // matrix 1 index 37, 74
    w 01001011 00000000000000000000000000000111 // matrix 1 index 38, 75
    w 01001100 00000000000000000000000000000101 // matrix 1 index 39, 76
    w 01001101 00000000000000000000000000010101 // matrix 1 index 40, 77
    w 01001110 00000000000000000000000000010100 // matrix 1 index 41, 78
    w 01001111 00000000000000000000000000000101 // matrix 1 index 42, 79
    w 01010000 00000000000000000000000000000100 // matrix 1 index 43, 80
    w 01010001 00000000000000000000000000000110 // matrix 1 index 44, 81
    w 01010010 00000000000000000000000000000101 // matrix 1 index 45, 82
    w 01010011 00000000000000000000000000010000 // matrix 1 index 46, 83
    w 01010100 00000000000000000000000000010001 // matrix 1 index 47, 84
    w 01010101 00000000000000000000000000010011 // matrix 1 index 48, 85
    w 01010110 00000000000000000000000000010000 // matrix 1 index 49, 86    
    w 01010111 00000000000000000000000000010010 // matrix 1 index 50, 87    
    w 01011000 00000000000000000000000000010110 // matrix 1 index 51, 88    
    w 01011001 00000000000000000000000000010110 // matrix 1 index 52, 89    
    w 01011010 00000000000000000000000000001010 // matrix 1 index 53, 90  
    w 01011011 00000000000000000000000000001011 // matrix 1 index 54, 91  
    w 01011100 00000000000000000000000000001111 // matrix 1 index 55, 92  
    w 01011101 00000000000000000000000000001011 // matrix 1 index 56, 93  
    w 01011110 00000000000000000000000000001101 // matrix 1 index 57, 94
    w 01011111 00000000000000000000000000001110 // matrix 1 index 58, 95
    w 01100000 00000000000000000000000000000110 // matrix 1 index 59, 96
    w 01100001 00000000000000000000000000000101 // matrix 1 index 60, 97
    w 01100010 00000000000000000000000000000111 // matrix 1 index 61, 98
    w 01100011 00000000000000000000000000100110 // matrix 1 index 62, 99
    w 01100100 00000000000000000000000000000110 // matrix 1 index 63, 100

    w 01100101 00000000000000000000000000000101 //  matrix 2 index 0, 101 
    w 01100110 00000000000000000000000000000111 //  matrix 2 index 1, 102 
    w 01100111 00000000000000000000000000000011 //  matrix 2 index 2, 103 
    w 01101000 00000000000000000000000000001011 //  matrix 2 index 3, 104 
    w 01101001 00000000000000000000000000001010 //  matrix 2 index 4, 105 
    w 01101010 00000000000000000000000000001011 //  matrix 2 index 5, 106 
    w 01101011 00000000000000000000000000001001 //  matrix 2 index 6, 107
    w 01101100 00000000000000000000000000001011 //  matrix 2 index 7, 108
    w 01101101 00000000000000000000000000001000 //  matrix 2 index 8, 109
    w 01101110 00000000000000000000000000000010 //  matrix 2 index 9, 110
    w 01101111 00000000000000000000000000001011 //  matrix 2 index 10, 111
    w 01110000 00000000000000000000000000000001 //  matrix 2 index 11, 112
    w 01110001 00000000000000000000000000000010 //  matrix 2 index 12, 113
    w 01110010 00000000000000000000000000000111 //  matrix 2 index 13, 114
    w 01110011 00000000000000000000000000010100 //  matrix 2 index 14, 115
    w 01110100 00000000000000000000000000010101 //  matrix 2 index 15, 116
    w 01110101 00000000000000000000000000010111 //  matrix 2 index 16, 117
    w 01110110 00000000000000000000000000010110 //  matrix 2 index 17, 118
    w 01110111 00000000000000000000000000010010 //  matrix 2 index 18, 119
    w 01111000 00000000000000000000000000010011 //  matrix 2 index 19, 120
    w 01111001 00000000000000000000000000000110 //  matrix 2 index 20, 121
    w 01111010 00000000000000000000000000000111 //  matrix 2 index 21, 122
    w 01111011 00000000000000000000000000000110 //  matrix 2 index 22, 123
    w 01111100 00000000000000000000000000000100 //  matrix 2 index 23, 124
    w 01111101 00000000000000000000000000000101 //  matrix 2 index 24, 125
    w 01111110 00000000000000000000000000000110 //  matrix 2 index 25, 126
    w 01111111 00000000000000000000000000011010 //  matrix 2 index 26, 127
    w 10000000 00000000000000000000000000011110 //  matrix 2 index 27, 128
    w 10000001 00000000000000000000000000000010 //  matrix 2 index 28, 129
    w 10000010 00000000000000000000000000000011 //  matrix 2 index 29, 130
    w 10000011 00000000000000000000000000100011 //  matrix 2 index 30, 131
    w 10000100 00000000000000000000000000100010 //  matrix 2 index 31, 132
    w 10000101 00000000000000000000000000100011 //  matrix 2 index 32, 133
    w 10000110 00000000000000000000000000100000 //  matrix 2 index 33, 134
    w 10000111 00000000000000000000000000100001 //  matrix 2 index 34, 135
    w 10001000 00000000000000000000000000000001 //  matrix 2 index 35, 136
    w 10001001 00000000000000000000000000000011 //  matrix 2 index 36, 137
    w 10001010 00000000000000000000000000000010 //  matrix 2 index 37, 138
    w 10001011 00000000000000000000000000000100 //  matrix 2 index 38, 139
    w 10001100 00000000000000000000000000001100 //  matrix 2 index 39, 140
    w 10001101 00000000000000000000000000001110 //  matrix 2 index 40, 141
    w 10001110 00000000000000000000000000000110 //  matrix 2 index 41, 142
    w 10001111 00000000000000000000000000000010 //  matrix 2 index 42, 143
    w 10010000 00000000000000000000000000000110 //  matrix 2 index 43, 144
    w 10010001 00000000000000000000000000000111 //  matrix 2 index 44, 145
    w 10010010 00000000000000000000000000000011 //  matrix 2 index 45, 146
    w 10010011 00000000000000000000000000001011 //  matrix 2 index 46, 147
    w 10010100 00000000000000000000000000001111 //  matrix 2 index 47, 148
    w 10010101 00000000000000000000000000000111 //  matrix 2 index 48, 149
    w 10010110 00000000000000000000000000001100 //  matrix 2 index 49, 150
    w 10010111 00000000000000000000000000000100 //  matrix 2 index 50, 151
    w 10011000 00000000000000000000000000000010 //  matrix 2 index 51, 152
    w 10011001 00000000000000000000000000001010 //  matrix 2 index 52, 153
    w 10011010 00000000000000000000000000001110 //  matrix 2 index 53, 154
    w 10011011 00000000000000000000000000000110 //  matrix 2 index 54, 155
    w 10011100 00000000000000000000000000000100 //  matrix 2 index 55, 156
    w 10011101 00000000000000000000000001000100 //  matrix 2 index 56, 157
    w 10011110 00000000000000000000000001001100 //  matrix 2 index 57, 158
    w 10011111 00000000000000000000010001000000 //  matrix 2 index 58, 159
    w 10100000 00000000000000000000010001000001 //  matrix 2 index 59, 160
    w 10100001 00000000000000000000000001000000 //  matrix 2 index 60, 161
    w 10100010 00000000000000000000000001000100 //  matrix 2 index 61, 162
    w 10100011 00000000000000000000000000001100 //  matrix 2 index 62, 163
    w 10100100 00000000000000000000000000001110 //  matrix 2 index 63, 164

    w 10100101 00000000000000000000000001000000 // WRITE SIZE OF MATRIX 1 TO MEMORY (64), 165
    w 10100110 00000000000000000000000010101010 // WRITE BEGINNING OF WHERE WE CAN WRITE NEW MATRIX TO MEMORY (171) TO MEMORY, 166

    w 10100111 00000000000000000000000000001000 // WRITE SIZE OF MATRIX 1 (8) TO MEMORY, 167
    w 10101000 00000000000000000000000000001000 // WRITE SIZE OF MATRIX 2 (8) TO MEMORY, 168
    w 10101001 00000000000000000000000000100101 // WRITE OFFSET OF INSTRUCTIONS/PROGRAM SETUP (37) TO MEMORY, 169

    
    
    
    
    

    



    PROPER INSTRUCTION FORMAT
    LD r0, m167
    LD r1, m168
    LD r8, m169
    LD r9, m165
    LD r12, m166
    ADD r2, #0, #0
    CMP r2, r0
    BGT m33
    ADD r3, #0, #0
    CMP r3, r1
    ADDGT r2, r2, #1
    BGT m6
    ADD r4, #0, #0
    ADD r5, #0, #0
    MUL r7, r0, r2
    ADD r7, r7, r8
    ADD r7, r7, r5
    ADD r10, #0, r3
    ADD r10, r10, r8
    ADD r10, r10, r9
    MUL r11, r0, r5
    ADD r10, r10, r11
    LD r7, r7
    LD r10, r10
    MUL r6, r7, r10
    ADD r4, r4, r6
    ADD r5, r5, #1
    CMP r5, r0
    STRGT r4, r12
    ADDGT r12, r12, #1
    ADDGT r3, r3, #1
    BGT m9
    B m14

    PROPER PROGRAM SETUP FORMAT:
    w 00100101 00000000000000000000000000001000
    w 00100110 00000000000000000000000000001010
    w 00100111 00000000000000000000000000001011
    w 00101000 00000000000000000000000000000100
    w 00101001 00000000000000000000000000000001
    w 00101010 00000000000000000000000000000100
    w 00101011 00000000000000000000000000000010
    w 00101100 00000000000000000000000000000011
    w 00101101 00000000000000000000000000000111
    w 00101110 00000000000000000000000000000110
    w 00101111 00000000000000000000000000010110
    w 00110000 00000000000000000000000000010111
    w 00110001 00000000000000000000000000000111
    w 00110010 00000000000000000000000000000110
    w 00110011 00000000000000000000000000000100
    w 00110100 00000000000000000000000000000101
    w 00110101 00000000000000000000000000000111
    w 00110110 00000000000000000000000000001111
    w 00110111 00000000000000000000000000001001
    w 00111000 00000000000000000000000000000001
    w 00111001 00000000000000000000000000000101
    w 00111010 00000000000000000000000000000100
    w 00111011 00000000000000000000000000010000
    w 00111100 00000000000000000000000000001000
    w 00111101 00000000000000000000000000000010
    w 00111110 00000000000000000000000000000011
    w 00111111 00000000000000000000000000000111
    w 01000000 00000000000000000000000000000110
    w 01000001 00000000000000000000000000000100
    w 01000010 00000000000000000000000000001100
    w 01000011 00000000000000000000000000001101
    w 01000100 00000000000000000000000000001111
    w 01000101 00000000000000000000000010000000
    w 01000110 00000000000000000000000010000001
    w 01000111 00000000000000000000000010000010
    w 01001000 00000000000000000000000010000011
    w 01001001 00000000000000000000000010000111
    w 01001010 00000000000000000000000010000101
    w 01001011 00000000000000000000000000000111
    w 01001100 00000000000000000000000000000101
    w 01001101 00000000000000000000000000010101
    w 01001110 00000000000000000000000000010100
    w 01001111 00000000000000000000000000000101
    w 01010000 00000000000000000000000000000100
    w 01010001 00000000000000000000000000000110
    w 01010010 00000000000000000000000000000101
    w 01010011 00000000000000000000000000010000
    w 01010100 00000000000000000000000000010001
    w 01010101 00000000000000000000000000010011
    w 01010110 00000000000000000000000000010000  
    w 01010111 00000000000000000000000000010010 
    w 01011000 00000000000000000000000000010110   
    w 01011001 00000000000000000000000000010110    
    w 01011010 00000000000000000000000000001010
    w 01011011 00000000000000000000000000001011
    w 01011100 00000000000000000000000000001111 
    w 01011101 00000000000000000000000000001011
    w 01011110 00000000000000000000000000001101
    w 01011111 00000000000000000000000000001110
    w 01100000 00000000000000000000000000000110
    w 01100001 00000000000000000000000000000101
    w 01100010 00000000000000000000000000000111
    w 01100011 00000000000000000000000000100110
    w 01100100 00000000000000000000000000000110
    w 01100101 00000000000000000000000000000101
    w 01100110 00000000000000000000000000000111
    w 01100111 00000000000000000000000000000011
    w 01101000 00000000000000000000000000001011
    w 01101001 00000000000000000000000000001010
    w 01101010 00000000000000000000000000001011
    w 01101011 00000000000000000000000000001001
    w 01101100 00000000000000000000000000001011
    w 01101101 00000000000000000000000000001000
    w 01101110 00000000000000000000000000000010
    w 01101111 00000000000000000000000000001011
    w 01110000 00000000000000000000000000000001
    w 01110001 00000000000000000000000000000010
    w 01110010 00000000000000000000000000000111
    w 01110011 00000000000000000000000000010100
    w 01110100 00000000000000000000000000010101
    w 01110101 00000000000000000000000000010111
    w 01110110 00000000000000000000000000010110
    w 01110111 00000000000000000000000000010010
    w 01111000 00000000000000000000000000010011
    w 01111001 00000000000000000000000000000110
    w 01111010 00000000000000000000000000000111
    w 01111011 00000000000000000000000000000110
    w 01111100 00000000000000000000000000000100
    w 01111101 00000000000000000000000000000101
    w 01111110 00000000000000000000000000000110
    w 01111111 00000000000000000000000000011010
    w 10000000 00000000000000000000000000011110
    w 10000001 00000000000000000000000000000010
    w 10000010 00000000000000000000000000000011
    w 10000011 00000000000000000000000000100011
    w 10000100 00000000000000000000000000100010
    w 10000101 00000000000000000000000000100011
    w 10000110 00000000000000000000000000100000
    w 10000111 00000000000000000000000000100001
    w 10001000 00000000000000000000000000000001
    w 10001001 00000000000000000000000000000011
    w 10001010 00000000000000000000000000000010
    w 10001011 00000000000000000000000000000100
    w 10001100 00000000000000000000000000001100
    w 10001101 00000000000000000000000000001110
    w 10001110 00000000000000000000000000000110
    w 10001111 00000000000000000000000000000010
    w 10010000 00000000000000000000000000000110
    w 10010001 00000000000000000000000000000111
    w 10010010 00000000000000000000000000000011
    w 10010011 00000000000000000000000000001011
    w 10010100 00000000000000000000000000001111
    w 10010101 00000000000000000000000000000111
    w 10010110 00000000000000000000000000001100
    w 10010111 00000000000000000000000000000100
    w 10011000 00000000000000000000000000000010
    w 10011001 00000000000000000000000000001010
    w 10011010 00000000000000000000000000001110
    w 10011011 00000000000000000000000000000110
    w 10011100 00000000000000000000000000000100
    w 10011101 00000000000000000000000001000100
    w 10011110 00000000000000000000000001001100
    w 10011111 00000000000000000000010001000000
    w 10100000 00000000000000000000010001000001
    w 10100001 00000000000000000000000001000000
    w 10100010 00000000000000000000000001000100
    w 10100011 00000000000000000000000000001100
    w 10100100 00000000000000000000000000001110
    w 10100101 00000000000000000000000001000000
    w 10100110 00000000000000000000000010101010
    w 10100111 00000000000000000000000000001000
    w 10101000 00000000000000000000000000001000
    w 10101001 00000000000000000000000000100101


    

