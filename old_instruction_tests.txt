   /* // LD TEST
    cout << "CYCLES: " << global_mem.get_cycles() << endl;
    global_mem.write("00000000", "01110001111000001000000000000000"); //write 2nd arg to addr in 1st arg. rn address is 00001000 (addr of value we want loaded into register)
    global_mem.write("00001000", "11111111111111111000111111111111"); // write value we want loaded (2nd arg) to mem addr = rn
    fetch(global_pc, global_mem, reg);
    cout << "FINISHED LD EXECUTION. PRINTING RESULTS..." << endl;
    cout << "reg 0: " << reg[0] << endl;
    cout << "cache address 00000000: \n" << global_mem.view("00000000", "1") << endl;
    cout << "NEW PC: " << global_pc << endl;
    cout << "CYCLES: " << global_mem.get_cycles() << endl;
    cout << "finish\n\n\n\n" << endl;

    // STR TEST
    LD r0, m3
    ADD r1, #2, #2
    STR r0, r1
    w 00000011 11111111111111111000111111111111

    // ADD TEST
    reg[2] = "00000000000000000000000000000001"; // 1st operand
    reg[3] = "00000000000000000000000000000001"; // 2nd operand
    string cond = "0000";
    string is_branch = "0";
    string i_bit = "0";
    string opcode = "00000";
    string s_bit = "0";
    string rn = "0010"; // first operand for add, reg[2] above
    string rd = "0100"; // dest register for add, we want reg[4]
    string shifter_operand = "001100000000"; // second operand register (reg[3]) + options for shift and constants
    global_mem.write("00000010", cond + is_branch + i_bit + opcode + s_bit + rn + rd + shifter_operand); // write command to memory
    fetch(global_pc, global_mem, reg);
    cout << "FINISHED ADD EXECUTION. PRINTING RESULTS..." << endl;
    cout << "REG[4], SHOULD BE 00000000000000000000000000000010: \n" + reg[4] << endl;
    cout << "NEW PC: " << global_pc << endl;
    cout << "CYCLES: " << global_mem.get_cycles() << endl;
    cout << "finish\n\n\n\n" << endl;


    // CMP AND LOOP JOINT TEST
    reg[2] = "00000000000000000000000000000001"; // 1st operand, 1
    reg[3] = "00000000000000000000000000000001"; // 2nd operand, 1
    cond = "0111"; // should save loop addr
    is_branch = "0";
    i_bit = "0";
    opcode = "01010";
    s_bit = "0";
    rn = "0010"; // first operand, reg[2] above
    rd = "0000"; // dest register, it'll ALWAYS BE GLOBAL_CMP and is set within decode(), so THIS DOESN'T MATTER
    shifter_operand = "001100000000"; // second operand register (reg[3]) + options for shift and constants
    global_mem.write("00000011", cond + is_branch + i_bit + opcode + s_bit + rn + rd + shifter_operand); // write command to memory
    fetch(global_pc, global_mem, reg);
    cout << "FINISHED CMP EXECUTION. PRINTING RESULTS..." << endl;
    cout << "RESULT (global_cmp), SHOULD BE 01: " + global_cmp << endl;
    cout << "GLOBAL LOOP, SHOULD BE BINARY VERSION OF THIS INSTRUCTION'S PC (3): " << global_loop << endl;
    cout << "NEW PC: " << global_pc << endl;
    cout << "CYCLES: " << global_mem.get_cycles() << endl;
    cout << "finish\n\n\n\n" << endl;

*/
    //BRANCH TEST -> THIS IS THE COUNTING LOOP

    CODE FORMAT
    /*string cond = "0011"; // less than cond code
    string is_branch = "0";
    string i_bit = "0";
    string opcode = "11000";
    string s_bit = "0";
    string target_address = "00000000000000000000"; // always will be global_loop where we look for this, DOESN'T MATTER
    global_mem.write("00000000", "0000 0 0 01111 0 00000111 0000 00000000"); // write first LD instruction to mem[0] (LD mem[7] to reg[0])
    global_mem.write("00000001", "0000 0 0 01111 0 00001000 0001 00000000"); // write second LD instruction to mem[1] (LD mem[8] to reg[1])
    global_mem.write("00000010", "0000 0 0 01111 0 00001001 0010 00000000");// write third LD instruction to mem[2] (LD mem[9] to reg[2])
    global_mem.write("00000011", "0000 0 0 00000 0 0000 0000 000100000000"); // write ADD command to mem[3] (ADD reg[0], reg[0], reg[1]).
    global_mem.write("00000100", "0000 0 0 01010 0 0000 0000 001000000000");// write CMP command to mem[4]. Compare reg[0] to reg[2], which holds 5 in binary. (CMP reg[0], reg[2], store result in global_cmp)
    global_mem.write("00000101", "0011 0 0 11000 0 00000000000000000011"); // write B to mem[5] (BLT target_address). The target addr is the first ins of loop. set less than cond code. target_addr is always global_loop
    global_mem.write("00000110", "0000 0 0 10001 0 00001010 0000 00000000") // write STR command to mem[6]. STR reg[0] into mem[10] at the end of the counting loop
    global_mem.write("00000111", "00000000000000000000000000000000"); // write 0 to mem[7]. we're adding 1 to this value in a loop
    global_mem.write("00001000", "00000000000000000000000000000001"); // write 1 to mem[8]. This is the "1" we're adding to em[6] every loop
    global_mem.write("00001001", "00000000000000000000000000000101"); // write 5 to mem[9]. We're CMPing this and mem[7] (reg[0]) to see if reg[0] is less than this*/

    FROM FILE FORMAT
    w 00000000 00000001111000000111000000000000 p
    w 00000001 00000001111000001000000100000000 p
    w 00000010 00000001111000001001001000000000 p
    w 00000011 00000000000000000000000100000000 p
    w 00000100 00000001010000000000001000000000 p
    w 00000101 00110011000000000000000000000011 p
    w 00000110 00000010001000001010000000000000 p
    w 00000111 00000000000000000000000000000000 n
    w 00001000 00000000000000000000000000000001 n
    w 00001001 00000000000000000000000000000101 n


    // SUB TEST - END RESULT SHOULD BE 00000000000000000000000000000001 IN REG[2]
    LD r0, m3 // LD mem[3] to reg[0] (first operand)
    LD r1, m4 // LD mem[4] to reg[1] (second operand)
    SUB r2, r0, r1 // SUB reg[0] - reg[1] and store it in reg[2]
    w 00000011 00000000000000000000000000000101 // write 5 to mem[3]
    w 00000100 00000000000000000000000000000100 // write 4 to mem[4]

    GOOD FORMAT FOR FILE
    LD r0, m3
    LD r1, m4
    SUB r2, r0, r1
    
    PROGRAM SETUP
    w 00000011 00000000000000000000000000000101
    w 00000100 00000000000000000000000000000100


    // MUL TEST - END RESULT SHOULD BE 00000000000000000000000000010100 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00010 0 0000 0010 000100000000 p // MUL reg[0] * reg[1] and store it in reg[2]
    w 00000011 00000000000000000000000000000101 n // write 5 to mem[3]
    w 00000100 00000000000000000000000000000100 n // write 4 to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000010000000010000100000000 p
    w 00000011 00000000000000000000000000000101 n
    w 00000100 00000000000000000000000000000100 n


    // DIV TEST - END RESULT SHOULD BE 00000000000000000000000000000010 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00011 0 0000 0010 000100000000 p // DIV reg[0] / reg[1] and store it in reg[2]
    w 00000011 00000000000000000000000000000110 n // write 6 to mem[3]
    w 00000100 00000000000000000000000000000011 n // write 3 to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000011000000010000100000000 p
    w 00000011 00000000000000000000000000000110 n
    w 00000100 00000000000000000000000000000011 n

    DIVIDE BY 0 TEST
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000011000000010000100000000 p
    w 00000011 00000000000000000000000000000110 n
    w 00000100 00000000000000000000000000000000 n


    // MOD TEST - END RESULT SHOULD BE 00000000000000000000000000000001 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00100 0 0000 0010 000100000000 p // MOD reg[0] % reg[1] and store it in reg[2]
    w 00000011 00000000000000000000000000000101 n // write 5 to mem[3]
    w 00000100 00000000000000000000000000000100 n // write 4 to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000100000000010000100000000 p
    w 00000011 00000000000000000000000000000101 n
    w 00000100 00000000000000000000000000000100 n


    MOD BY 0 TEST
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000100000000010000100000000 p
    w 00000011 00000000000000000000000000000101 n
    w 00000100 00000000000000000000000000000000 n


    // AND TEST - END RESULT SHOULD BE 00000000000000000000010100000100 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00101 0 0000 0010 000100000000 p // AND reg[0] && reg[1] and store it in reg[2]
    w 00000011 00000000000000000000010100000101 n // write to mem[3]
    w 00000100 00000000000000000000111100000100 n // write to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000101000000010000100000000 p
    w 00000011 00000000000000000000010100000101 n
    w 00000100 00000000000000000000111100000100 n


    // OR TEST - END RESULT SHOULD BE 00000000000000000000111100000101 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 00111 0 0000 0010 000100000000 p // OR reg[0] || reg[1] and store it in reg[2]
    w 00000011 00000000000000000000010100000101 n // write to mem[3]
    w 00000100 00000000000000000000111100000100 n // write to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000000111000000010000100000000 p
    w 00000011 00000000000000000000010100000101 n
    w 00000100 00000000000000000000111100000100 n


    // NOT TEST - END RESULT SHOULD BE 11111111000010111111101011111010 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand, NOT USED)
    w 00000010 0000 0 0 01000 0 0000 0010 000000000000 p // NOT reg[0] and store it in reg[2]
    w 00000011 00000000111101000000010100000101 n // write to mem[3]
    w 00000100 00000000000000000000111100000100 n // write to mem[4], NOT USED

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000001000000000010000000000000 p
    w 00000011 00000000111101000000010100000101 n
    w 00000100 00000000000000000000111100000100 n


    // XOR TEST - END RESULT SHOULD BE 00000000000000000000101000000001 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand)
    w 00000010 0000 0 0 01001 0 0000 0010 000100000000 p // XOR reg[0] x|| reg[1] and store it in reg[2]
    w 00000011 00000000000000000000010100000101 n // write to mem[3]
    w 00000100 00000000000000000000111100000100 n // write to mem[4]

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000001001000000010000100000000 p
    w 00000011 00000000000000000000010100000101 n
    w 00000100 00000000000000000000111100000100 n


    // MOV TEST - END RESULT SHOULD BE 00000000000000000000010100000101 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (NOT USED)
    w 00000010 0000 0 0 01011 0 0000 0010 000000000000 p // MOV reg[0] into reg[2]
    w 00000011 00000000000000000000010100000101 n // write to mem[3]
    w 00000100 00000000000000000000111100000100 n // write to mem[4], NOT USED

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000001011000000010000000000000 p
    w 00000011 00000000000000000000010100000101 n
    w 00000100 00000000000000000000111100000100 n  


    // LS TEST - END RESULT SHOULD BE 00000000000000000000000000110000 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand, UNUSED)
    w 00000010 0000 0 0 10111 0 0000 0010 000110000000 p // LS reg[0] 3 spaces and store it in reg[2]
    w 00000011 11100000000000000000000000000110 n // write to mem[3]
    w 00000100 00000000000000000000000000000011 n // write to mem[4], UNUSED

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000010111000000010000110000000 p
    w 00000011 11100000000000000000000000000110 n
    w 00000100 00000000000000000000000000000011 n

    // RS TEST - END RESULT SHOULD BE 00011100000000000000000000011000 IN REG[2]
    w 00000000 0000 0 0 01111 0 00000011 0000 00000000 p // LD mem[3] to reg[0] (first operand)
    w 00000001 0000 0 0 01111 0 00000100 0001 00000000 p // LD mem[4] to reg[1] (second operand, UNUSED)
    w 00000010 0000 0 0 10000 0 0000 0010 000110000000 p // RS reg[0] 3 spaces and store it in reg[2]
    w 00000011 11100000000000000000000011000110 n // write to mem[3]
    w 00000100 00000000000000000000000000000011 n // write to mem[4], UNUSED

    GOOD FORMAT FOR FILE
    w 00000000 00000001111000000011000000000000 p
    w 00000001 00000001111000000100000100000000 p
    w 00000010 00000010000000000010000110000000 p
    w 00000011 11100000000000000000000011000110 n
    w 00000100 00000000000000000000000000000011 n


    // BASIC COUNTING LOOP ASSEMBLY THAT WORKS:
    LD r0, m7
    LD r1, m8
    LD r2, m9
    ADD r0, r0, r1
    CMP r0, r0, r2
    BLT m3
    STR r0, m6
    
    
    // 4/12 DEMO PROGRAM
    SUBTRACTION TO 0 LOOP, ADD 4 TO IT, MULTIPLY BY 4, DIVIDE BY 2, MOD 2, AND IT WITH ONE REG, OR IT WITH ANOTHER, NOT, XOR WITH AND REG, MOV TO ANOTHER REG, LS BY 2, RS BY 4
    reg[0] = 5, reg[1] = 1, reg[2] = 0, reg[3] = 4
    
    THEORETICAL CODE FORMAT
    global_mem.write("00000000", "0000 0 0 01111 0 00010101 0000 00000000"); // write first LD instruction to mem[0] (LD mem[21] to reg[0])
    global_mem.write("00000001", "0000 0 0 01111 0 00010110 0001 00000000"); // write second LD instruction to mem[1] (LD mem[22] to reg[1])
    global_mem.write("00000010", "0000 0 0 01111 0 00010111 0010 00000000");// write third LD instruction to mem[2] (LD mem[23] to reg[2])
    global_mem.write("00000011", "0000 0 0 00001 0 0000 0000 000100000000"); // write SUB command to mem[3] (SUB reg[0], reg[0], reg[1])
    global_mem.write("00000100", "0000 0 0 01010 0 0000 0000 001000000000");// write CMP command to mem[4]. Compare reg[0] to reg[2], which holds 0 in binary. (CMP reg[0], reg[2], store result in global_cmp)
    global_mem.write("00000101", "0101 0 0 11000 0 00000000000000000011"); // write B to mem[5] (BGT target_address). The target addr is the first ins of loop. set greater than cond code
    global_mem.write("00000110", "0000 0 0 10001 0 00011001 0000 00000000"); // write STR command to mem[6]. STR reg[0] into mem[25] at the end of the counting loop
    RESULT SHOULD BE 0 in reg[0], 1 in reg[1], 0 in reg[2]
    global_mem.write("00000111", "0000 0 0 01111 0 00011000 0011 00000000"); // write LD ins to mem[7] (LD mem[24] into reg[3])
    global_mem.write("00001000", "0000 0 0 00000 0 0000 0000 001100000000"); // write ADD ins to mem[8] (ADD reg[3] to reg[0])
    RESULT SHOULD BE 4 IN REG[0]
    global_mem.write("00001001", "0000 0 0 00010 0 0000 0000 000000000000"); // write MUL ins to mem[9] (MUL reg[0] by reg[0])
    RESULT SHOULD BE 16 IN REG[0]
    global_mem.write("00001010", "0000 0 0 00000 0 0001 0001 000100000000"); // write ADD ins to mem[10] (ADD reg[1] TO reg[1])
    RESULT SHOULD BE 2 IN REG[1]
    global_mem.write("00001011", "0000 0 0 00011 0 0000 0000 000100000000"); // write DIV ins to mem[11] (DIV reg[0] by reg[1])
    RESULT SHOULD BE 8 IN REG[0]
    global_mem.write("00001100", "0000 0 0 00100 0 0000 0000 000100000000"); // write MOD ins to mem[12] (MOD reg[0] by reg[1])
    RESULT SHOULD BE 0 IN REG[0]
    global_mem.write("00001101", "0000 0 0 00101 0 0000 0000 000100000000"); // write AND ins to mem[13] (AND reg[0] w/ reg[1])
    RESULT SHOULD STILL BE 0 IN REG[0]
    global_mem.write("00001110", "0000 0 0 00111 0 0000 0000 001100000000"); // write OR ins to mem[14] (OR reg[0] w/ reg[3])
    RESULT SHOULD BE 4 IN REG[0]
    global_mem.write("00001111", "0000 0 0 01000 0 0000 0000 000000000000"); // write NOT ins to mem[15] (NOT reg[0])
    RESULT SHOULD BE 11111111111111111111111111111011 IN REG[0]
    global_mem.write("00010000", "0000 0 0 01001 0 0000 0000 000100000000"); // write XOR ins to mem[16] (XOR reg[0] w/ reg[1])
    RESULT SHOULD BE 11111111111111111111111111111001 IN REG[0]
    global_mem.write("00010001", "0000 0 0 01011 0 0000 0010 000000000000"); // write MOV ins to mem[17] (MOV reg[0] to reg[2])
    RESULT SHOULD BE 11111111111111111111111111111001 IN REG[0] AND REG[2]
    global_mem.write("00010010", "0000 0 0 10111 0 0010 0010 000100000000"); // write LS ins to mem[18] (LS reg[2] by 2)
    RESULT SHOULD BE 11111111111111111111111111100100 IN REG[2]
    global_mem.write("00010011", "0000 0 0 10000 0 0010 0010 001000000000"); // write RS ins to mem[19] (RS reg[2] by 4)
    RESULT SHOULD BE 00001111111111111111111111111110 IN REG[2]
    global_mem.write("00010100", "0000 0 0 10001 0 00011010 0010 00000000"); // write STR ins to mem[20] (STR reg[2] in mem[26])
    global_mem.write("00010101", "00000000000000000000000000000101"); // write 5 to mem[21]. we're subtracting 1 to this value in a loop
    global_mem.write("00010110", "00000000000000000000000000000001"); // write 1 to mem[22]. This is the "1" we're adding to em[6] every loop
    global_mem.write("00010111", "00000000000000000000000000000000"); // write 0 to mem[23]. We're CMPing this and mem[7] (reg[0]) to see if reg[0] is less than this*/
    global_mem.write("00011000", "00000000000000000000000000000100"); // write 4 to mem[24]. 

    FINAL RESULT SHOULD BE:
    reg[0] = 11111111111111111111111111111001
    reg[1] = 00000000000000000000000000000010
    reg[2] = 00001111111111111111111111111110
    reg[3] = 00000000000000000000000000000100
    mem[25] = 00000000000000000000000000000000
    mem[26] = 00001111111111111111111111111110

    FORMAT FOR FILE
    w 00000000 00000001111000010101000000000000 p
    w 00000001 00000001111000010110000100000000 p
    w 00000010 00000001111000010111001000000000 p
    w 00000011 00000000001000000000000100000000 p
    w 00000100 00000001010000000000001000000000 p
    w 00000101 01010011000000000000000000000011 p
    w 00000110 00000010001000011001000000000000 p
    w 00000111 00000001111000011000001100000000 p
    w 00001000 00000000000000000000001100000000 p
    w 00001001 00000000010000000000000000000000 p
    w 00001010 00000000000000010001000100000000 p
    w 00001011 00000000011000000000000100000000 p
    w 00001100 00000000100000000000000100000000 p
    w 00001101 00000000101000000000000100000000 p
    w 00001110 00000000111000000000001100000000 p
    w 00001111 00000001000000000000000000000000 p
    w 00010000 00000001001000000000000100000000 p
    w 00010001 00000001011000000010000000000000 p
    w 00010010 00000010111000100010000100000000 p
    w 00010011 00000010000000100010001000000000 p
    w 00010100 00000010001000011010001000000000 p
    w 00010101 00000000000000000000000000000101 n
    w 00010110 00000000000000000000000000000001 n
    w 00010111 00000000000000000000000000000000 n
    w 00011000 00000000000000000000000000000100 n

    ASSEMBLER FORMAT (OLD SLOW WAY USING ALL REGISTERS, STILL WORKS OFC):
    LD r0, m21
    LD r1, m22
    LD r2, m23
    SUB r0, r0, r1
    CMP r0, r2
    BGT m3
    STR r0, m25
    LD r3, m24
    ADD r0, r0, r3
    MUL r0, r0, r0
    ADD r1, r1, r1
    DIV r0, r0, r1
    MOD r0, r0, r1
    AND r0, r0, r1
    OR r0, r0, r3
    NOT r0, r0
    XOR r0, r0, r1
    MOV r2, r0
    LS r2, r2, #2
    RS r2, r2, #4
    STR r2, m26
    
    ASSEMBLER FORMAT (NEW WAY USING #'s):
    LD r0, m21
    SUB r0, r0, #1
    CMP r0, #0
    BGT m1
    STR r0, m25
    ADD r0, r0, #4
    MUL r0, r0, #4
    DIV r0, r0, #2
    MOD r0, r0, #2
    AND r0, r0, #2
    OR r0, r0, #4
    NOT r0, r0
    XOR r0, r0, #2
    MOV r1, r0
    LS r1, r1, #2
    RS r1, r1, #4
    STR r1, m26

    PROGRAM SETUP:
    w 00010101 00000000000000000000000000000101 n
    w 00010110 00000000000000000000000000000001 n
    w 00010111 00000000000000000000000000000000 n
    w 00011000 00000000000000000000000000000100 n



    *********BENCHMARKS**********

    **BENCHMARK 1: EXCHANGE SORT**
    memory will hold array of values
    r0 = 
    r1 = size of array we're sorting
    r2 = 1st operand to compare in inner loop sort
    r3 = 2nd operand to compare in inner loop sort
    r4 = counter for outer loop
    r5 = limit the outer loop can count up to
    r6 = counter for inner loop
    r7 = limit the inner loop can count up to
    r8 = offset marking the memory location of the first index of array to be sorted
    r9 = changes, has memory address of current index we want for inner loop
    
    EXCHANGE SORT ASSEMBLER FORMAT + PROGRAM SETUP (w/ explanation)
    LD r8, m23 // loads offset to beginning of array (IDK) for sort into r8: 0
    LD r1, m22 // loads size of array (30) into r1: 1
    ADD r4, r4, #0 // set outer counter to 0: 2
    SUB r5, r1, #2 // set outer loop limit to (size of array - 2): 3
    ADD r6, r6, #0 // set inner counter to 0, BRANCH TO HERE FOR TOP OF OUTER LOOP: 4
    SUB r7, r5, r4 // set inner loop limit to (size of array - 2 - outer counter): 5
    CMP r6, r7 // compare inner counter to inner loop limit, BRANCH TO HERE FOR TOP OF INNER LOOP: 6
    BGT m19 // branch to the end of the inner loop if greater than, we're done with this inner loop: 7
    ADD r9, r6, r8 // add inner counter and mem offset, r9 has int val of memory location with array value we need: 8
    LD r2, r9 // load the value at the memory location in r9 to r2, first operand: 9
    ADD r9, r9, #1 // add 1 to the memory location so we can get the adjacent value to compare: 10
    LD r3, r9 // load the value at the memory location in r9 to r2, second operand: 11
    CMP r2, r3 // compare the operands: 12
    ADD r6, r6, #1 // add 1 to inner count for an iteration in case we don't go down to reverse values and branch back up: 13
    BLTE m6 // if they're in the right order (r2 <= r3), just iterate again and don't update anything: 14
    STR r2, r9 // if r2 > r3, store r2 where r3 was in memory: 15
    SUB r9, r9, #1 // if r2 > r3, decrement r9 back to r2's original memory location: 16
    STR r3, r9 // if r2 > r3, store r3 where r2 was in memory. Now these 2 values are in the right order.: 17
    B m6 // repeat inner loop iteration for next two array values: 18
    ADD r4, r4, #1 // increment counter of outer loop. BRANCH HERE FOR THE END OF INNER LOOP, FIRST INS AFTER END: 19
    CMP r4, r5 // compare outer loop limit and counter: 20
    BLTE m4 // repeat if the counter is <= the limit: 21

    w 00010110 00000000000000000000000000011110 // WRITE 30 (size of array) TO memory: 22
    w 00010111 00000000000000000000000000011000 // WRITE 24 (# of instructions + # of writes for program setup) to memory: 23
    // write all 30 array values to memory locations 24 - 53
    w 00011000 00000000000110000000000000011000 // 24
    w 00011001 00000000000000000000000000011011 // 25
    w 00011010 00000000000000000000000000011111 // 26
    w 00011011 00110000000000000000000000011000 // 27
    w 00011100 00000001100000000000000000000000 // 28
    w 00011101 10000000000000000000000000011000 // 29
    w 00011110 00100000000000000000000000011011 // 30
    w 00011111 00100000000000000000000000011000 // 31
    w 00100000 00100001111000000000000000011011 // 32
    w 00100001 00000001111000000000000000011011 // 33
    w 00100010 00100001111000000000000000000011 // 34
    w 00100011 00100001101000000000000000011011 // 35
    w 00100100 10100001111000000000000000011011 // 36
    w 00100101 00101101111000000000000000011011 // 37
    w 00100110 00100000000000001010000000011011 // 38
    w 00100111 00100000000001001010000000011011 // 39
    w 00101000 00100000000000001010000000011000 // 40
    w 00101001 00100100000000001010000000011011 // 41
    w 00101010 00101100000000001010000000011011 // 42
    w 00101011 00100000000000001010000000000011 // 43
    w 00101100 00100011110000001010000000011011 // 44
    w 00101101 00100000000000000000000000011011 // 45
    w 00101110 11100000000000001010000000011011 // 46
    w 00101111 00000000000000001010000000011011 // 47
    w 11000000 00100000000000001010000000000000 // 48
    w 11000001 11111000000000001010000000011011 // 49
    w 11000010 11111000000000001010000000011000 // 50
    w 11000011 00000000000000001010000000011000 // 51
    w 00110100 00000000000000001010000000000011 // 52
    w 00110101 01000000000000001010000000000000 // 53
    w 00110110 01100000000000001010000000000011 // 54




    
    ASSEMBLER INSTRUCTIONS AND PROGRAM SETUP IN FILE FORMAT:
    LD r8, m23
    LD r1, m22
    ADD r4, #0, #0
    SUB r5, r1, #2
    ADD r6, #0, #0
    SUB r7, r5, r4
    CMP r6, r7
    BGT m19
    ADD r9, r6, r8
    LD r2, r9
    ADD r9, r9, #1
    LD r3, r9
    CMP r2, r3
    ADD r6, r6, #1
    BLTE m6
    STR r2, r9
    SUB r9, r9, #1
    STR r3, r9
    B m6
    ADD r4, r4, #1
    CMP r4, r5
    BLTE m4

    w 00010110 00000000000000000000000000011110
    w 00010111 00000000000000000000000000011000
    w 00011000 00000000000000000000000000011000
    w 00011001 00000000000000000000000000011011
    w 00011010 00000000000000000000000000011111
    w 00011011 00000000000000000000000000011000
    w 00011100 00000000000000000000000000000001
    w 00011101 00000000000000000000000000011000
    w 00011110 00000000000000000000000000011011
    w 00011111 00000000000000000000000000011000
    w 00100000 00000000000000000000000000011011
    w 00100001 00000000000000000000000000011011
    w 00100010 00000000000000000000000000000011
    w 00100011 00000000000000000000000000011011
    w 00100100 00000000000000000000000000011011
    w 00100101 00000000000000000000000000011011
    w 00100110 00000000000000001010000000011011
    w 00100111 00000000000001001010000000011011
    w 00101000 00000000000000001010000000011000
    w 00101001 00000000000000001010000000011011
    w 00101010 00000000000000001010000000011011
    w 00101011 00000000000000001010000000000011
    w 00101100 00000000000000001010000000011011
    w 00101101 00000000000000000000000000011011
    w 00101110 00000000000000001010000000011011
    w 00101111 00000000000000001010000000011011
    w 11000000 00000000000000001010000000000000
    w 11000001 00000000000000001010000000011011
    w 11000010 00000000000000001010000000011000
    w 11000011 00000000000000001010000000011000
    w 00110100 00000000000000001010000000000011
    w 00110101 00000000000000001010000000000000
    w 00110110 00000000000000001010000000000011

    
    
    **BENCHMARK 2: MATRIX MULTIPLY**
    

